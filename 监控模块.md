数据采集接口

数据上报接口

数据存储和计算



数据采集有两种方式

* 方式一：整个过程采集两次（温度，内存，电量）

  <String,Result>

* 方式二：在执行每次任务的时候前后采集两次（CPU使用率）

  ```HashMap<String,Result>```



现阶段的想法是

* ~~针对每一个监控模块自己存储相应的数据~~
* 单独设计一种数据结构，每一个监控模块复杂采样，把数据放到里面去。而Service负责初始化该结构。这样做可以在Service执行任务失败了，也能把数据上报上去

数据的格式

* ```java
  map<String,int>
  ```

  这种方式有点很明显，就是数据存储方便，但是不能记录当前Service的状态，比如正在执行何种任务，

* 类比Test，那边是用一个Result来封住结果，再把结构发送给benchmarkBL。

  针对数据的存储的格式，对两种采样方式进行区别，方式一可以通过单独的数据结构进行存储，但是方式二还是需要集成到Result中(这样就不符合我的预期了)

* 另一种方法，默认添加两个测试，开始和结束测试，并将测试结果加入到原本的result中

```java
public class BenchmarkMonitorBase{
  String Monitor_name;
  public BenchmarkMonitorResult smaple();//把数据打到对应的数据结构中
  public static List<BenchmarkMonitorBase> initBenchmarkMonitor(){return null;}
}
```

如何初始化？

​	通过BenchmarkMonitorBase的init进行初始化，但当监控指标变多后会变得比较繁杂

如何循环调用？

```java
//针对方式一
Service{
  List<BenchmarkMonitorResult> BenchmarkMonitorResults = new ArrayList<>();
  List<BenchmarkMonitorBase> BenchmarkMonitors = BenchmarkMonitorBase::initBenchmarkMonitor();
  for(BenchmarkMonitorBase BenchmarkMonitor : BenchmarkMonitors){
    BenchmarkMonitorResults.add(BenchmarkMonitor.sample());
  }
}
```

方式二和方式一的区别在于方式二需要和对应的taskresult进行绑定。



数据上报方式：

现阶段性能监控的上报方式和benchmark的上报方式是分开的，如果是合在一起的话，就不需要针对CPU这样的采集方式进行单独的区分。如果性能监控是单独上报的话，就要针对方式二要额外增加数据接口，但是如果有多个方式二采集的数据，是否可以将这些数据结合到一起。



预期效果

```json
{
  "Memory":["before":89%,"after":89%],
  "CPU":12,//平均使用率
  "task_name1":[
   "before":["CPU":100,"otherMonitor":70],
    "after":["CPU":100,"otherMonitor":70]
  ],
   "task_name2":[
   "before":["CPU":100,"otherMonitor":70],
    "after":["CPU":100,"otherMonitor":70]
  ]
  "temperature":["before":38.6,"after":40.5]，
	"power":["before":38.6,"after":40.5]
}

```

那么根据上述的方案，设计一个result格式

```java
Map<String,map<String,Result>>
  
inner class Result{
  int before;
  int after;
}
```



```java
class MonitorFactory//有可拓展的初始化列表，调用其中的构造函数可以返回和初始化列表对应的MonitorBase
class MointorBase;
class Result;
//高可用，使用方便，功能可拓展，拓展时对原本系统代码修改量不高
//可以自定义选择监控对象， 通过enum来动态生成对应的监控对象
//监控的时机
//对上提供统一的接口
```



如果要实现接口的可复用，那么该模块就不应该负责处理业务逻辑，那么该模块只负责采集数据，~~那么对数据存储呢以及简单的处理呢~~

，所以还要实现一个可配置的数据存储功能。



如何初始化？

如何在最开始的时候自动初始化？

如果是工厂类，那么还是要传入需要初始化的数据，动态初始化。



那么设计一个工厂类，在Monitor中自动加入相应的初始化列表，并可配置。



方式一和方式二该如何实现？

如何区别还是如何统一

~~如果针对每个任务执行前都进行采样，那么可以直接加在test中~~

还是要分开

* 需要判断这个Monitor是否需要监控，<u>**加个标志位进行判断**</u>
* ~~还是在初始化的时候就要分开~~

```java
Service{
switch(msg.what){
  case MSG_INIT_TASK:
    List<BenchmarkMonitorResult> BenchmarkMonitorResults = new ArrayList<>();
    List<BenchmarkMonitorBase> BenchmarkMonitors = BenchmarkMonitorFactory.getMonitors();
    for(BenchmarkMonitorBase BenchmarkMonitor : BenchmarkMonitors){
    	BenchmarkMonitorResults.add(BenchmarkMonitor.sample());
  	}
    //上报数据
    break;
  case MSG_RUN_TASK:
    BenchmarkTestBase task = (BenchmarkTestBase) msg.obj;
    for(BenchmarkMonitorBase BenchmarkMonitor : BenchmarkMonitors){
      if(BenchmarkMonitor.needrun())
    	BenchmarkMonitorResults.add(BenchmarkMonitor.sample());
  	}
    task.beforerun();
    task.run();
    task.afterrun();
    for(BenchmarkMonitorBase BenchmarkMonitor : BenchmarkMonitors){
      if(BenchmarkMonitor.needrun())
    	BenchmarkMonitorResults.add(BenchmarkMonitor.sample());
  	}
    if(last){
    	for(BenchmarkMonitorBase BenchmarkMonitor : BenchmarkMonitors){
    		BenchmarkMonitorResults.add(BenchmarkMonitor.sample());
  		}
			//上报数据
    }
}
}
```



数据如何上报

通过Result上报，









